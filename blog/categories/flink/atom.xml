<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Flink | Tech Notes]]></title>
  <link href="http://ogibayashi.github.io/blog/categories/flink/atom.xml" rel="self"/>
  <link href="http://ogibayashi.github.io/"/>
  <updated>2016-05-27T20:55:01+09:00</updated>
  <id>http://ogibayashi.github.io/</id>
  <author>
    <name><![CDATA[OGIBAYASHI Hironori]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Apache Flinkを試してみての感想]]></title>
    <link href="http://ogibayashi.github.io/blog/2016/05/13/thoughts-on-apache-flink/"/>
    <updated>2016-05-13T19:42:13+09:00</updated>
    <id>http://ogibayashi.github.io/blog/2016/05/13/thoughts-on-apache-flink</id>
    <content type="html"><![CDATA[<p>しばらくApache Flinkを試してみたので、感想を書いておこうと思う.</p>

<h2>試したこと</h2>

<ul>
<li>standalone modeでのクラスタ構築</li>
<li>ストリーミングジョブを書いてみる

<ul>
<li>TumblingTimeWindowやSlidingTimeWindowでの集計</li>
<li>Kafka SourceとElasticsearch Sinkの利用</li>
<li>必要だったので、カスタムトリガは書いた</li>
</ul>
</li>
<li>幾つかのジョブで性能測定</li>
<li>社内の本番fluentdからKafka経由でFlinkにストリームを投入し、ジョブを十数日くらい連続稼働してみる</li>
<li>state backendをHDFSやRocksDBにしてみる</li>
<li>JobManager HA</li>
<li>TaskManagerやJobManagerを落としてみる</li>
<li>Flink on YARN (ジョブを起動してみただけ)</li>
</ul>


<h2>試してないこと</h2>

<ul>
<li>DataSet APIの利用</li>
<li>savepoint, savepointからの復旧</li>
<li>event timeやingenstion timeの利用(processing timeしか使ってない)</li>
<li>複数ジョブの相乗り</li>
<li>高トラフィックかつ複数ジョブでの連続稼働</li>
<li>Flink on YARNをもうちょっと色々使ってみる</li>
<li>(多分他にも色々)</li>
</ul>


<h2>所感</h2>

<p>全体としてはすごく良く出来ていると思う. プロセスが落ちたりしても勝手に復旧するし、性能も出るし、WebUIやREST APIで色々情報取れるので運用もしやすそう. 今後は本番に入れていこうと思っている.</p>

<ul>
<li>ちゃんと動く？

<ul>
<li>期待通りに動かなくて、MLで聞いたらBugだ、って言われて直してくれたのが2件</li>
<li>ContinuousProcessingTimeTriggerは期待通りの動作をしなかったので、修正版を書く必要があった</li>
<li>後は、上記の範囲では特に問題なく動いている</li>
</ul>
</li>
<li>処理の書きやすさ

<ul>
<li>APIがハイレベルなので、割と少ないコードで処理を書くことができて良い</li>
<li>状態の保存とか、windowとか、自分で書くのは大変なのでその辺の面倒はFlinkが見てくれる</li>
</ul>
</li>
<li>性能

<ul>
<li>もちろん処理によるが、単純なものであれば1CPUで10万records/sec以上は普通に処理できそう</li>
</ul>
</li>
<li>耐障害性

<ul>
<li>ジョブ実行中にJobManagerやTaskManagerを落としてみたが、勝手に復旧された. すごい.</li>
<li>HDFS障害でどう振る舞うか？はまだ試せてないけど気になるところ</li>
</ul>
</li>
<li>運用

<ul>
<li>WebUIやREST APIで色々取れる. WebUIで大抵のものは見える印象.</li>
<li>スロット数とかはもちろん、ジョブ内のオペレータ単位で処理レコード数とか取れる</li>
<li>チェックポイントの所要時間やサイズも取れる</li>
</ul>
</li>
<li>不安なところ

<ul>
<li>チェックポイントのサイズには注意がいりそう. FsStateBackendの場合、状態は全て各TaskManagerのメモリに持ち、チェックポイントでHDFSに書き出される. 差分スナップショット的なものはないので、状態が大きくなってくるとスナップショットに時間がかかり、性能劣化する. キー(keyByで指定する奴)の数が大きいケースでは、RocksDBを使うことで改善されるらしいが、まだそれが有効なケースに出会ってない.</li>
<li>FlinkジョブをYARNで動かす場合を除いて、各TaskManagerは1プロセスで、その中で複数ジョブがスレッドとして動く形になっているのでisolationの部分は不安. あるジョブに引きづられてTaskManagerが固まるとかありそう.</li>
<li>ストリーム処理のプロダクトはいくつかあるし、Facebook, Twitter, Likedinみたいな大御所がバックにいるわけではないので、生き残っていくのだろうか</li>
</ul>
</li>
</ul>


<h2>まとめ</h2>

<p>ということで、自分がしばらく試しての所感を書いてみた.
実績の少ないプロダクトという意味での不安感はあるけど、性能、拡張性、耐障害性、APIの使いやすさは素晴らしいと思うので、使っていきたい. これ以上は使ってみないとわからないと思うし. あと、Flink on YARNの場合はYARNが動くクラスタがあれば、別途サーバを用意しなくてもFlinkジョブを動かすことができるので、既にHadoop環境がある場合なんかは、とりあえず試してみると良いんじゃないかと思う.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Apache Flinkを試している]]></title>
    <link href="http://ogibayashi.github.io/blog/2016/02/26/trying-apache-flink/"/>
    <updated>2016-02-26T20:38:01+09:00</updated>
    <id>http://ogibayashi.github.io/blog/2016/02/26/trying-apache-flink</id>
    <content type="html"><![CDATA[<p>耐障害性と拡張性のあるストリーム処理基盤が欲しい、と思って<a href="https://flink.apache.org/">Apache Flink</a>を調べている. 今はリアルタイム集計に<a href="http://norikra.github.io/">Norikra</a>を使っていて、これはとてもカジュアルに使えて良いのだけど、以下の様なケースだと難しい。</p>

<ul>
<li>比較的止めたくない処理で、サーバ障害時にも自動的に回復して欲しい</li>
<li>1日とか長いtime windowの集計をしているので、途中でサーバが落ちて集計中の状態が失われると辛い</li>
<li>トラフィックが増えてきて、複数サーバに負荷を分散したい</li>
<li>例えばストリームに含まれているIDに対応する値を外部のテーブルから取ってくるような、ちょっと複雑な処理をしたい</li>
</ul>


<h3>Flinkとはどのようなソフトウェアか</h3>

<p>一言で言うと、対障害性と拡張性を備えた、分散ストリーム処理基盤。バッチ処理もストリーム処理の仕組みでできるよね、ということでバッチ用、ストリーム用両方のAPIが提供されている。実行環境としては、Hadoop等と同じようにワーカプロセスが複数のサーバで立ち上がっていて、そこに対してジョブを投げるような感じになっている。バッチではジョブを投げるとデータを処理して終了、だけど、ストリーム処理では投げたジョブはずっと生きていて、ストリームにデータが流れてくるたびにそのデータを処理して出力する、という形になる。ジョブは、JavaとScalaで書くことができる。ロードマップにはSQL的なものもあるっぽいけど、今は存在しない。</p>

<h3>SparkとかStormと何が違うの？</h3>

<p>ググると色々出てくるが、<a href="https://yahooeng.tumblr.com/post/135321837876/benchmarking-streaming-computation-engines-at">米Yahooのベンチマーク</a>とか、<a href="http://www.altaterra.net/blogpost/288668/225612/Which-Stream-Processing-Engine-Storm-Spark-Samza-or-Flink">このページ</a>が分かりやすかった。</p>

<p>Stromとの比較で言うと、処理形態はほぼ同じ。ただ、大きな違いとしてStormでは各処理オペレータはstatelessになっていて、落ちると状態が失われる。永続化したかったら、自分で外部ストレージを使うようなコードを書く必要がある。耐障害性ということろだと、各レコードに対して処理が完了した際にackを返す仕組みがあるので、障害などでackが無かったら再度処理する、というような処理を書く感じになる。なので、例えば処理が途中まで行われて障害になると、そのレコードは重複して処理される形になる。Flinkは<a href="https://ci.apache.org/projects/flink/flink-docs-master/internals/stream_checkpointing.html">ここ</a>に詳しく書いてあるけど、オペレータがstatefulになっていて、チェックポイントごとに状態が保存される。障害時には、チェックポイントから復旧し、それ以降のレコードをリプレイすることで、exactly-onceを実現している。</p>

<p>あとは、Stormだと各処理オペレータ(Bolt)をJavaのクラスとして書かないといけないけど、Flinkは<code>stream.keyBy(...).map{...}.timeWindow(...)</code>みたいな感じのハイレベルのAPIが提供されている。</p>

<p>Spark Streamingとの違いで言うと、Spark Streamingは正確にはストリーミングではなくてマイクロバッチなので、そのバッチの間隔にストリーム処理のwindowが左右される。sliding time windowとか、一定数のレコードを保持するようなwindowは作ることができない。(ちゃんとドキュメント読んでないけど、そのはず)</p>

<h3>触ってみた</h3>

<p>とりあえず触ってみるには、<a href="https://ci.apache.org/projects/flink/flink-docs-release-0.10/quickstart/setup_quickstart.html">https://ci.apache.org/projects/flink/flink-docs-release-0.10/quickstart/setup_quickstart.html</a> に従えば良い。</p>

<p>ざっくりした流れとしては、</p>

<ul>
<li>バイナリをダウンロードして展開</li>
<li><code>./bin/start-local.sh</code> 実行</li>
<li><a href="http://localhost:8081/">http://localhost:8081/</a> でJobManagerを開く</li>
<li>exampleがバイナリと一緒に配布されているので、それを実行</li>
</ul>


<p>という感じで試すことができる。</p>

<p>クラスタを組むのも割と簡単で、 <a href="https://ci.apache.org/projects/flink/flink-docs-release-0.10/setup/cluster_setup.html">https://ci.apache.org/projects/flink/flink-docs-release-0.10/setup/cluster_setup.html</a> に従えばできる。</p>

<p>JobManagerというのがマスタで、TaskManagerというのがワーカになっているので、これをサーバに分散配置することになる。</p>

<p>流れとしては、</p>

<ul>
<li>各サーバにflink用のユーザとssh keyを用意

<ul>
<li>ssh keyは、起動スクリプトの中でssh経由でTaskManagerを起動するので必要.自分で各サーバのTaskManagerを起動して回るなら無くても良い</li>
</ul>
</li>
<li>各サーバにバイナリを配布</li>
<li>設定ファイル(flink-conf.yaml, slaves)を用意

<ul>
<li>flink-conf.yamlは、配布されているものをそのまま使って、JobManagerのアドレスを設定すれば良い</li>
<li>slavesはTaskManagerホストを列挙したもの。クラスタ起動スクリプトの中で使われる</li>
</ul>
</li>
</ul>


<p>となる。
  ジョブを書くには、<a href="https://ci.apache.org/projects/flink/flink-docs-release-0.10/quickstart/scala_api_quickstart.html">https://ci.apache.org/projects/flink/flink-docs-release-0.10/quickstart/scala_api_quickstart.html</a> に従う。mavenのアーキタイプが用意されてるので、それでプロジェクトのテンプレートを作って、ドキュメントの中にあるWordCountをコピーして走らせれば良い。</p>

<h3>感想</h3>

<p>試しにfluend→Kafka→Flink→Elasticsearch、とつなげて分散実行してみたり、プロセスを落としてみたりしたが、期待通りに動作した。例えば、5分間のtime windowで件数を集計するような処理を作って、実行中にプロセスを落とすと、障害が検知されてジョブが再実行される。そして、勝手に必要なリカバリがされるので、障害があっても無くても実行結果は変わらない。すごい。(もう少しちゃんと見ると、ずれるケースもありそうだけど、まだ詳しく見ていない)</p>

<p>並列度は、ジョブの投入時に指定できるので、ちゃんとKafkaのパーティションを複数作って並列度を指定して実行すれば、各TaskManagerに分散して実行される。</p>

<p>ただ、性能のところが今一つで、処理を3サーバに分散、5,000msg/secを投入してやってみたら、各サーバ1CPUを100%使って、Kafkaにメッセージが滞留する状態になった。実際に処理できたのは4,300msg/secくらい。3CPUで4,300msg/secだと大分コストが高いなあ、という印象。まあ、とりあえず動かしてみただけなので、何か正しくない可能性はある。もう少し試してみたい。</p>
]]></content>
  </entry>
  
</feed>
