<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Fluentd | Tech Notes]]></title>
  <link href="http://ogibayashi.github.io/blog/categories/fluentd/atom.xml" rel="self"/>
  <link href="http://ogibayashi.github.io/"/>
  <updated>2015-03-30T22:25:13+09:00</updated>
  <id>http://ogibayashi.github.io/</id>
  <author>
    <name><![CDATA[OGIBAYASHI Hironori]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[FluentdのFilter&Label周りのコードを読んだメモ]]></title>
    <link href="http://ogibayashi.github.io/blog/2015/03/24/code-reading-of-fluentd-v0-dot-12-filter-and-label-related/"/>
    <updated>2015-03-24T13:45:46+09:00</updated>
    <id>http://ogibayashi.github.io/blog/2015/03/24/code-reading-of-fluentd-v0-dot-12-filter-and-label-related</id>
    <content type="html"><![CDATA[<p>Fluentd v0.12の目玉機能としてFilterとLabelがある. この機能の導入にあたってはメッセージのルーティングを行う部分のコードがガラリと変わっているはずなので、興味本位で読んでみた.</p>

<h2>機能についての参考文書</h2>

<p>そもそもFilterやLabelって何？というあたりは以下が参考になる。</p>

<ul>
<li><a href="http://repeatedly.github.io/ja/2014/08/fluentd-filter-and-label/">Fluentd v0.12でのFilterとLabel</a></li>
<li><a href="http://www.fluentd.org/blog/fluentd-v0.12-is-released">Fluentd v0.12 is Released</a></li>
<li><a href="http://qiita.com/muran001/items/f73d19398b750abb9c2d">Fluentd v0.12の目玉機能らしいFilterを試してみた</a></li>
<li><a href="http://qiita.com/sonots/items/a01d2233210b7b059967">Fluentd v0.12 ラベル機能の使い方とプラグインの改修方法</a></li>
</ul>


<h2>v0.10ではどうだったか</h2>

<p>Matchクラスが<code>match</code>ディレクティブで宣言されたタグのパターンと、行き先のOutputクラスを保持していて、<code>EngineClass#emit</code> (最終的な呼び出し先は<code>emit_stream</code>)で該当するMatchを探し出し、そこに向けて<code>emit</code>する、という形だった.</p>

<p>```ruby
  def emit_stream(tag, es)</p>

<pre><code>  target = @match_cache[tag]
  unless target
    target = match(tag) || NoMatchMatch.new
    # this is not thread-safe but inconsistency doesn't
    # cause serious problems while locking causes.
    if @match_cache_keys.size &gt;= MATCH_CACHE_SIZE
      @match_cache.delete @match_cache_keys.shift
    end
    @match_cache[tag] = target
    @match_cache_keys &lt;&lt; tag
  end
  target.emit(tag, es)
</code></pre>

<p>```</p>

<p>なので、ルーティングを管理するテーブルは<code>EngineClass</code>の<code>@matches</code>一つだったし、tagがルーティングのキーになっていた. 複数のOutputで順番に処理したい場合は都度tagを書き換えていく必要があった.</p>

<h2>v0.12の場合</h2>

<p><code>Agent</code>, <code>RootAgent</code>, <code>Label</code>, <code>EventRouter</code>と言った新しいクラスが導入されている.</p>

<ul>
<li><code>Label</code>

<ul>
<li>各<code>label</code>ディレクティブの中に存在するFilterおよびOutputプラグインを管理するクラス</li>
</ul>
</li>
<li><code>RootAgent</code>

<ul>
<li><code>label</code>ディレクティブに属さない(設定ファイルのルート直下にある)Input, Filter, Outputプラグイン、および各Labelクラスを管理するクラス</li>
</ul>
</li>
<li><code>Agent</code>

<ul>
<li><code>RootAgent</code>および<code>Label</code>の親クラス.</li>
</ul>
</li>
<li><code>EventRouter</code>

<ul>
<li>ルーティングのためのルール(どのタグパターンに対して、どのようなfilterやmatchが存在するか)を管理し、イベントのルーティングを行うクラス</li>
</ul>
</li>
</ul>


<p><code>RootAgent</code>および<code>Label</code>のインスタンスは、それぞれ自分自身が管理する範囲のルーティングを行う<code>EventRouter</code>クラスのインスタンスを保持している.</p>

<p>以下、実際のコードを見てみる.</p>

<h2>起動部分</h2>

<p>まずは、configurationを読み込んでいく段階でどのようなクラスが生成されていくのかを見てみる.</p>

<h3>Supervisor#start (init_engine)</h3>

<p><a href="https://github.com/fluent/fluentd/blob/f6aa9a4b275e4e9885bb912bcf0e930966d8e246/lib/fluent/supervisor.rb#L124">Supervisor#start</a></p>

<p>Supervisorが起動して、色々と準備していく部分. <code>init_engine</code>内で <a href="https://github.com/fluent/fluentd/blob/f6aa9a4b275e4e9885bb912bcf0e930966d8e246/lib/fluent/engine.rb#L41">Engine#init</a> が呼ばれ、ここで<code>RootAgent</code>が生成される.</p>

<p><code>RootAgent</code>の親クラスである<code>Agent</code>のコンストラクタは以下のようになっている</p>

<p><a href="https://github.com/fluent/fluentd/blob/f6aa9a4b275e4e9885bb912bcf0e930966d8e246/lib/fluent/agent.rb#L29">Agent#initialize</a></p>

<p>```ruby</p>

<pre><code>def initialize(opts = {})
  super()

  @context = nil
  @outputs = []
  @filters = []
  @started_outputs = []
  @started_filters = []

  @log = Engine.log
  @event_router = EventRouter.new(NoMatchMatch.new(log), self)
  @error_collector = nil
end
</code></pre>

<p>```</p>

<p>自身が管理するOutputクラス、Filterクラス達を保持するための変数が存在している. また、そのスコープでのルーティングを行う<code>EventRouter</code>クラスをここで生成している.</p>

<p><code>RootAgent</code>については、これに加えて更にInputやLabelクラスも管理するような構造になっている. (<a href="https://github.com/fluent/fluentd/blob/f6aa9a4b275e4e9885bb912bcf0e930966d8e246/lib/fluent/root_agent.rb#L46">root_agent.rb</a>)</p>

<h3>Supervisor#start (run_configure)</h3>

<p><code>Supervisor#run_conigure</code>が呼ばれると、<code>Engine#configure</code>を経由して<code>RootAgent#configure</code>が呼ばれる.</p>

<p><a href="https://github.com/fluent/fluentd/blob/f6aa9a4b275e4e9885bb912bcf0e930966d8e246/lib/fluent/root_agent.rb#L62">RootAgent#configure</a></p>

<p>ちょっと長いが引用.これにより以下が行われる</p>

<ul>
<li>labelディレクティブがあった場合

<ul>
<li> <a href="https://github.com/fluent/fluentd/blob/f6aa9a4b275e4e9885bb912bcf0e930966d8e246/lib/fluent/root_agent.rb#L155">add_label</a>により新規<code>Label</code>オブジェクトを生成</li>
<li> さらに、その<code>Label</code>オブジェクトの<code>configure</code>を呼び出す. <code>configure</code>の内容については、以下の<code>Agent#configure</code>を参照.</li>
</ul>
</li>
<li>sourceディレクティブがあった場合

<ul>
<li><a href="https://github.com/fluent/fluentd/blob/f6aa9a4b275e4e9885bb912bcf0e930966d8e246/lib/fluent/root_agent.rb#L141">add_source</a>によりInputプラグインのインスタンスを生成</li>
<li>Inputプラグインがemitする際の投げ先として、以下を登録.

<ul>
<li>そのInputプラグインで<code>@label</code>が設定されている場合→設定された<code>Label</code>オブジェクトの<code>EventRouter</code>を登録</li>
<li>それ以外の場合→<code>RootAgent</code>の<code>EventRouter</code>を登録</li>
</ul>
</li>
</ul>
</li>
</ul>


<p>Inputプラグインについては<code>@label</code>が設定されている場合とそうでない場合で、emit先の<code>EventRouter</code>を切り替えることができるようになっている.</p>

<p>```ruby</p>

<pre><code>def configure(conf)
  error_label_config = nil

  # initialize &lt;label&gt; elements before configuring all plugins to avoid 'label not found' in input, filter and output.
  label_configs = {}
  conf.elements.select { |e| e.name == 'label' }.each { |e|
    name = e.arg
    raise ConfigError, "Missing symbol argument on &lt;label&gt; directive" if name.empty?

    if name == ERROR_LABEL
      error_label_config = e
    else
      add_label(name)
      label_configs[name] = e
    end
  }
  # Call 'configure' here to avoid 'label not found'
  label_configs.each { |name, e| @labels[name].configure(e) }
  setup_error_label(error_label_config) if error_label_config

  super

  # initialize &lt;source&gt; elements
  if @without_source
    log.info "'--without-source' is applied. Ignore &lt;source&gt; sections"
  else
    conf.elements.select { |e| e.name == 'source' }.each { |e|
      type = e['@type'] || e['type']
      raise ConfigError, "Missing 'type' parameter on &lt;source&gt; directive" unless type
      add_source(type, e)
    }
  end
end
</code></pre>

<p>```</p>

<p>さらに、<code>RootAgent</code>の親クラスである<code>Agent#configure</code>では同様にmatchに対して<code>add_match</code>、filterについて<code>add_filter</code>が呼ばれる.</p>

<p><a href="https://github.com/fluent/fluentd/blob/f6aa9a4b275e4e9885bb912bcf0e930966d8e246/lib/fluent/agent.rb#L50">Anget#configure</a></p>

<p>```ruby</p>

<pre><code>def configure(conf)
  super

  # initialize &lt;match&gt; and &lt;filter&gt; elements
  conf.elements.select { |e| e.name == 'filter' || e.name == 'match' }.each { |e|
    pattern = e.arg.empty? ? '**' : e.arg
    type = e['@type'] || e['type']
    if e.name == 'filter'
      add_filter(type, pattern, e)
    else
      add_match(type, pattern, e)
    end
  }
end
</code></pre>

<p>```</p>

<p><code>Agent</code>は<code>Label</code>の親クラスでもあるので、新しい<code>Label</code>オブジェクトの<code>configure</code>が呼び出された際もこのコードが実行されることになる.</p>

<p><a href="https://github.com/fluent/fluentd/blob/f6aa9a4b275e4e9885bb912bcf0e930966d8e246/lib/fluent/agent.rb#L134">add_filter</a>や<a href="https://github.com/fluent/fluentd/blob/f6aa9a4b275e4e9885bb912bcf0e930966d8e246/lib/fluent/agent.rb#L122">add_match</a>が何をしているかというと、その<code>Agent</code>が持っている<code>EventRouter</code>に対してルーティングのルール(<code>Rule</code>オブジェクト)を登録している.</p>

<h3>絵にすると、、、</h3>

<p><a href="http://www.fluentd.org/blog/fluentd-v0.12-is-released">FluentdのBlog</a>に書かれているサンプルを元に、どんな感じのオブジェクトたちが出来上がるかを絵にするとこんな感じ.</p>

<p><img src="/images/2015/201503_Fluentd_Routing.png" alt="RootAgent" /></p>

<p>labelごとにルーティングテーブルを持つので、labelが違えば異なるルールでルーティングする、ということができるようになる.</p>

<h2>emitの動き</h2>

<p>ここまでで、各Input, Filter, Outputプラグインインスタンスは、自分がemitする先の<code>EventRouter</code>オブジェクトを知っていることになる.</p>

<p>まず、Inputプラグイン内では自分が知っている<code>EventRouter</code>に<code>emit</code>する.</p>

<p><code>ruby
router.emit(tag, time, record)
</code></p>

<p><code>emit</code>は<code>emit_stream</code>に飛ぶので、以下のコードが呼び出される. <code>match</code>メソッドが返してきたオブジェクトに対して<code>emit</code>する.</p>

<p><a href="https://github.com/fluent/fluentd/blob/f6aa9a4b275e4e9885bb912bcf0e930966d8e246/lib/fluent/event_router.rb#L87">EventRouter#emit_stream</a></p>

<p>```ruby</p>

<pre><code>def emit_stream(tag, es)
  match(tag).emit(tag, es, @chain)
rescue =&gt; e
  @emit_error_handler.handle_emits_error(tag, es, e)
end
</code></pre>

<p>```</p>

<p><a href="https://github.com/fluent/fluentd/blob/f6aa9a4b275e4e9885bb912bcf0e930966d8e246/lib/fluent/event_router.rb#L101">EventRouter#match</a> に飛ぶ. <code>match</code>はemitされたtagを受け取るべきCollectorを返す.</p>

<p>```ruby</p>

<pre><code>def match(tag)
  collector = @match_cache.get(tag) {
    c = find(tag) || @default_collector
  }
  collector
end
</code></pre>

<p>```</p>

<p>このCollectorを探す部分がどうなっているかと言うと、</p>

<p><a href="https://github.com/fluent/fluentd/blob/f6aa9a4b275e4e9885bb912bcf0e930966d8e246/lib/fluent/event_router.rb#L156">event_router#find</a></p>

<p>こんな感じになっている. つまり、Filterが使われていれば<code>Pipeline</code>オブジェクトを生成してそこにFilterやOutputを順次追加していく. Filterがなければ<code>Pipeline</code>の代わりにOutputを直接返す.</p>

<p>```ruby</p>

<pre><code>def find(tag)
  pipeline = nil
  @match_rules.each_with_index { |rule, i|
    if rule.match?(tag)
      if rule.collector.is_a?(Filter)
        pipeline ||= Pipeline.new
        pipeline.add_filter(rule.collector)
      else
        if pipeline
          pipeline.set_output(rule.collector)
        else
          # Use Output directly when filter is not matched
          pipeline = rule.collector
        end
        return pipeline
      end
    end
  }

  if pipeline
    # filter is matched but no match
    pipeline.set_output(@default_collector)
    pipeline
  else
    nil
  end
end
</code></pre>

<p>```</p>

<p>よって、<code>emit</code>されたレコードは<code>Pipeline</code>または<code>Output</code>に<code>emit</code>されることになる. そして、<code>Pipeline</code>に<code>emit</code>された場合は以下のコードに辿り着き、順番にFilterを通った後に最終的にOutputに<code>emit</code>されることになる.</p>

<p><a href="https://github.com/fluent/fluentd/blob/f6aa9a4b275e4e9885bb912bcf0e930966d8e246/lib/fluent/event_router.rb#L147">Pipeline#emit</a></p>

<p>```ruby</p>

<pre><code>  def emit(tag, es, chain)
    processed = es
    @filters.each { |filter|
      processed = filter.filter_stream(tag, processed)
    }
    @output.emit(tag, processed, chain)
  end
</code></pre>

<p>```</p>

<p>このようにFilterを実現するためにPipelineという新しい仕組みを導入しているため、tagの書き換えによる多段フィルタをしなくて済むようになっている.</p>

<h2>まとめ</h2>

<ul>
<li>v0.12のLabel, Filterを実現している部分のコードを読んでみた</li>
<li>Labelの部分は、RootAgent(設定ファイルのROOT部分)および各labelディレクティブごとにルーティングテーブル(<code>EventRouter</code>)を分けることにより実現されている</li>
<li>Filterは、レコードに対する連続した処理を表現する、Pipelineという新たな仕組みを導入することで実現されている</li>
</ul>

]]></content>
  </entry>
  
</feed>
